# Compare [Magical Record](https://github.com/MagicalPanda/MagicalRecord) and [Mantle](https://github.com/Mantle/Mantle).

В данном примере проекта описывается пример сериализации из JSON и маппинга данных в CoreData через библиотеки **Mantle** и **Magical Record**. В корне проекта есть папки с _.xcdatamodeld_ и _Entities_ для каждого библиотеки отдельно. С помощью препроцессорной константы ```TEST_MAGICAL_RECORD``` можно переключаться между их логикой работы. В _AppDelegate_ происходит запись или обновление записей, в _MasterViewController_ отображаются данные и управление ими и в _DetailViewController_ отображается описание выбранного объекта.

Для **Magical Record** сгенерированы 2 модели - **Person** и **Address**. Для сериализации присутствуют 4 разных JSON с одинаковыми ключами. **Attributes** у **Person** мапятся с помощью ключа **mappedKeyName**(может быть несколько и описывается, как **mappedKeyName.[0-9]**), где _value_ - ключ в самом JSON. Для **Enitites** у **Person** есть ключ **relatedByAttribute**, которое указывает, каким будет уникальное property у класса (может быть только одно) и по нему мы будем проверять _NSManagedObject_ объекты на уникальность. Для мапинга **relationship** **Address** у **Person** также используется ключ **mappedKeyName** и для указания уникальности объекта также по ключу **relatedByAttribute**.
В _AppDelegate_ создается стек и парсятся данные из четырех разных JSON с разными случаями. Например, в методах ```- (void)johnSmith``` и ```- (void)updatedJohnSmith``` пример добавления или обновления записи в бд конкретного объекта. В методах ```- (void)registerUsers``` и ```- (void)registerUsersViaOtherEndpoint``` пример добавления нескольких объектов.

Для **Mantle** сгенерированы 4 модели - **Issue**, унаследованные от неё **Bug** и **Question**, **User**. Эта библиотека для сериализации и мапинга использует паттерн _Adapter_ и для сериализации используются классы **MTLJSONAdapter** и наследники от **MTLModel**, которые должны реализовать протокол **MTLJSONSerializing**. В этом протоколе для наследника от класса **MTLModel** мы описываем «карту» для сериализации методам ```+ (NSDictionary *)JSONKeyPathsByPropertyKey```. Также мы можем указать, как конвертировать конкретное JSON значение с помощью **NSValueTransformer** и метода ```+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key```, а также класс, который должен быть создан через метод ```+ (Class)classForParsingJSONDictionary:(NSDictionary *)JSONDictionary``` (это удобно, если мы имеем много наследников от одного абстрактного класса). Используя **MTLJSONAdapter** делаем сериализацию данных ```+ (id)modelOfClass:(Class)modelClass fromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error``` для одного объекта или ```+ (NSArray *)modelsOfClass:(Class)modelClass fromJSONArray:(NSArray *)JSONArray error:(NSError **)error``` для массива. И для получения **NSManagedObject** мы используем **MTLManagedObjectAdapter** через метод ```+ (id)managedObjectFromModel:(MTLModel<MTLManagedObjectSerializing> *)model insertingIntoContext:(NSManagedObjectContext *)context error:(NSError **)error```. 